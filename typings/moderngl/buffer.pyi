"""
This type stub file was generated by pyright.
"""

__all__ = ['Buffer']
class Buffer:
    '''
        Buffer objects are OpenGL objects that store an array of unformatted memory
        allocated by the OpenGL context, (data allocated on the GPU).
        These can be used to store vertex data, pixel data retrieved from images
        or the framebuffer, and a variety of other things.

        A Buffer object cannot be instantiated directly, it requires a context.
        Use :py:meth:`Context.buffer` to create one.

        Copy buffer content using :py:meth:`Context.copy_buffer`.
    '''
    __slots__ = ...
    def __init__(self) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    @property
    def size(self) -> int:
        '''
            int: The size of the buffer in bytes.
        '''
        ...
    
    @property
    def dynamic(self) -> bool:
        '''
            bool: Is the buffer created with the dynamic flag?
        '''
        ...
    
    @property
    def glo(self) -> int:
        '''
            int: The internal OpenGL object.
            This values is provided for debug purposes only.
        '''
        ...
    
    def write(self, data, *, offset=...) -> None:
        '''
            Write the content.

            Args:
                data (bytes): The data.

            Keyword Args:
                offset (int): The offset.
        '''
        ...
    
    def write_chunks(self, data, start, step, count) -> None:
        '''
            Split data to count equal parts.

            Write the chunks using offsets calculated from start, step and stop.

            Args:
                data (bytes): The data.
                start (int): First offset.
                step (int): Offset increment.
                count (int): The number of offsets.
        '''
        ...
    
    def read(self, size=..., *, offset=...) -> bytes:
        '''
            Read the content.

            Args:
                size (int): The size. Value ``-1`` means all.

            Keyword Args:
                offset (int): The offset.

            Returns:
                bytes
        '''
        ...
    
    def read_into(self, buffer, size=..., *, offset=..., write_offset=...) -> None:
        '''
            Read the content into a buffer.

            Args:
                buffer (bytearray): The buffer that will receive the content.
                size (int): The size. Value ``-1`` means all.

            Keyword Args:
                offset (int): The read offset.
                write_offset (int): The write offset.
        '''
        ...
    
    def read_chunks(self, chunk_size, start, step, count) -> bytes:
        '''
            Read the content.

            Read and concatenate the chunks of size chunk_size
            using offsets calculated from start, step and stop.

            Args:
                chunk_size (int): The chunk size.
                start (int): First offset.
                step (int): Offset increment.
                count (int): The number of offsets.

            Returns:
                bytes
        '''
        ...
    
    def read_chunks_into(self, buffer, chunk_size, start, step, count, *, write_offset=...) -> None:
        '''
            Read the content.

            Read and concatenate the chunks of size chunk_size
            using offsets calculated from start, step and stop.

            Args:
                buffer (bytearray): The buffer that will receive the content.
                chunk_size (int): The chunk size.
                start (int): First offset.
                step (int): Offset increment.
                count (int): The number of offsets.

            Keyword Args:
                write_offset (int): The write offset.
        '''
        ...
    
    def clear(self, size=..., *, offset=..., chunk=...) -> None:
        '''
            Clear the content.

            Args:
                size (int): The size. Value ``-1`` means all.

            Keyword Args:
                offset (int): The offset.
                chunk (bytes): The chunk to use repeatedly.
        '''
        ...
    
    def bind_to_uniform_block(self, binding=..., *, offset=..., size=...) -> None:
        '''
            Bind the buffer to a uniform block.

            Args:
                binding (int): The uniform block binding.

            Keyword Args:
                offset (int): The offset.
                size (int): The size. Value ``-1`` means all.
        '''
        ...
    
    def bind_to_storage_buffer(self, binding=..., *, offset=..., size=...) -> None:
        '''
            Bind the buffer to a shader storage buffer.

            Args:
                binding (int): The shader storage binding.

            Keyword Args:
                offset (int): The offset.
                size (int): The size. Value ``-1`` means all.
        '''
        ...
    
    def orphan(self, size=...) -> None:
        '''
            Orphan the buffer with the option to specify a new size.

            It is also called buffer re-specification.

            Reallocate the buffer object before you start modifying it.

            Since allocating storage is likely faster than the implicit synchronization,
            you gain significant performance advantages over synchronization.

            The old storage will still be used by the OpenGL commands that have been sent previously.
            It is likely that the GL driver will not be doing any allocation at all,
            but will just be pulling an old free block off the unused buffer queue and use it,
            so it is likely to be very efficient.

            Keyword Args:
                size (int): The new byte size if the buffer. If not supplied
                            the buffer size will be unchanged.

            .. rubric:: Example

            .. code-block:: python

                # For simplicity the VertexArray creation is omitted

                >>> vbo = ctx.buffer(reserve=1024)

                # Fill the buffer

                >>> vbo.write(some_temporary_data)

                # Issue a render call that uses the vbo

                >>> vao.render(...)

                # Orphan the buffer

                >>> vbo.orphan()

                # Issue another render call without waiting for the previous one

                >>> vbo.write(some_temporary_data)
                >>> vao.render(...)

                # We can also resize the buffer. In this case we double the size

                >> vbo.orphan(vbo.size * 2)
        '''
        ...
    
    def release(self) -> None:
        '''
            Release the ModernGL object.
        '''
        ...
    
    def bind(self, *attribs, layout=...): # -> tuple[Self@Buffer, Unknown | None, *tuple[Unknown, ...]]:
        """Helper method for binding a buffer.

        Returns:
            (self, layout, *attribs) tuple
        """
        ...
    
    def assign(self, index): # -> tuple[Self@Buffer, Unknown]:
        """Helper method for assigning a buffer.

        Returns:
            (self, index) tuple
        """
        ...
    


