"""
This type stub file was generated by pyright.
"""

from typing import Dict, Set, Tuple
from .buffer import Buffer
from .compute_shader import ComputeShader
from .framebuffer import Framebuffer
from .program import Program
from .query import Query
from .renderbuffer import Renderbuffer
from .scope import Scope
from .texture import Texture
from .texture_3d import Texture3D
from .texture_array import TextureArray
from .texture_cube import TextureCube
from .vertex_array import VertexArray
from .sampler import Sampler

__all__ = ['Context', 'create_context', 'create_standalone_context', 'NOTHING', 'BLEND', 'DEPTH_TEST', 'CULL_FACE', 'RASTERIZER_DISCARD', 'PROGRAM_POINT_SIZE', 'ZERO', 'ONE', 'SRC_COLOR', 'ONE_MINUS_SRC_COLOR', 'SRC_ALPHA', 'ONE_MINUS_SRC_ALPHA', 'DST_ALPHA', 'ONE_MINUS_DST_ALPHA', 'DST_COLOR', 'ONE_MINUS_DST_COLOR', 'FUNC_ADD', 'FUNC_SUBTRACT', 'FUNC_REVERSE_SUBTRACT', 'MIN', 'MAX', 'DEFAULT_BLENDING', 'ADDITIVE_BLENDING', 'PREMULTIPLIED_ALPHA', 'FIRST_VERTEX_CONVENTION', 'LAST_VERTEX_CONVENTION']
NOTHING = ...
BLEND = ...
DEPTH_TEST = ...
CULL_FACE = ...
RASTERIZER_DISCARD = ...
PROGRAM_POINT_SIZE = ...
ZERO = ...
ONE = ...
SRC_COLOR = ...
ONE_MINUS_SRC_COLOR = ...
SRC_ALPHA = ...
ONE_MINUS_SRC_ALPHA = ...
DST_ALPHA = ...
ONE_MINUS_DST_ALPHA = ...
DST_COLOR = ...
ONE_MINUS_DST_COLOR = ...
FUNC_ADD = ...
FUNC_SUBTRACT = ...
FUNC_REVERSE_SUBTRACT = ...
MIN = ...
MAX = ...
DEFAULT_BLENDING = ...
ADDITIVE_BLENDING = ...
PREMULTIPLIED_ALPHA = ...
FIRST_VERTEX_CONVENTION = ...
LAST_VERTEX_CONVENTION = ...
class Context:
    '''
        Class exposing OpenGL features.
        ModernGL objects can be created from this class.
    '''
    NOTHING = ...
    BLEND = ...
    DEPTH_TEST = ...
    CULL_FACE = ...
    RASTERIZER_DISCARD = ...
    PROGRAM_POINT_SIZE = ...
    POINTS = ...
    LINES = ...
    LINE_LOOP = ...
    LINE_STRIP = ...
    TRIANGLES = ...
    TRIANGLE_STRIP = ...
    TRIANGLE_FAN = ...
    LINES_ADJACENCY = ...
    LINE_STRIP_ADJACENCY = ...
    TRIANGLES_ADJACENCY = ...
    TRIANGLE_STRIP_ADJACENCY = ...
    PATCHES = ...
    NEAREST = ...
    LINEAR = ...
    NEAREST_MIPMAP_NEAREST = ...
    LINEAR_MIPMAP_NEAREST = ...
    NEAREST_MIPMAP_LINEAR = ...
    LINEAR_MIPMAP_LINEAR = ...
    ZERO = ...
    ONE = ...
    SRC_COLOR = ...
    ONE_MINUS_SRC_COLOR = ...
    SRC_ALPHA = ...
    ONE_MINUS_SRC_ALPHA = ...
    DST_ALPHA = ...
    ONE_MINUS_DST_ALPHA = ...
    DST_COLOR = ...
    ONE_MINUS_DST_COLOR = ...
    DEFAULT_BLENDING = ...
    ADDITIVE_BLENDING = ...
    PREMULTIPLIED_ALPHA = ...
    FUNC_ADD = ...
    FUNC_SUBTRACT = ...
    FUNC_REVERSE_SUBTRACT = ...
    MIN = ...
    MAX = ...
    FIRST_VERTEX_CONVENTION = ...
    LAST_VERTEX_CONVENTION = ...
    __slots__ = ...
    def __init__(self) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    @property
    def line_width(self) -> float:
        '''
        .. Warning:: A line width other than 1.0 is not guaranteed to work
                     across different OpenGL implementations. For wide
                     lines you should be using geometry shaders.

            float: Set the default line width.
        '''
        ...
    
    @line_width.setter
    def line_width(self, value): # -> None:
        ...
    
    @property
    def point_size(self) -> float:
        '''
            float: Set/get the default point size.
        '''
        ...
    
    @point_size.setter
    def point_size(self, value): # -> None:
        ...
    
    @property
    def depth_func(self) -> str:
        '''
            int: Set the default depth func.
            The depth function is set using a string.

            Example::

                ctx.depth_func = '<='  # GL_LEQUAL
                ctx.depth_func = '<'   # GL_LESS
                ctx.depth_func = '>='  # GL_GEQUAL
                ctx.depth_func = '>'   # GL_GREATER
                ctx.depth_func = '=='  # GL_EQUAL
                ctx.depth_func = '!='  # GL_NOTEQUAL
                ctx.depth_func = '0'   # GL_NEVER
                ctx.depth_func = '1'   # GL_ALWAYS
        '''
        ...
    
    @depth_func.setter
    def depth_func(self, value): # -> None:
        ...
    
    @property
    def blend_func(self):
        '''
            tuple: Set the blend func (write only)
            Blend func can be set for rgb and alpha separately if needed.

            Supported blend functions are::

                moderngl.ZERO
                moderngl.ONE
                moderngl.SRC_COLOR
                moderngl.ONE_MINUS_SRC_COLOR
                moderngl.DST_COLOR
                moderngl.ONE_MINUS_DST_COLOR
                moderngl.SRC_ALPHA
                moderngl.ONE_MINUS_SRC_ALPHA
                moderngl.DST_ALPHA
                moderngl.ONE_MINUS_DST_ALPHA

            Example::

                # For both rgb and alpha
                ctx.blend_func = moderngl.SRC_ALPHA, moderngl.ONE_MINUS_SRC_ALPHA

                # Separate for rgb and alpha
                ctx.blend_func = (
                    moderngl.SRC_ALPHA, moderngl.ONE_MINUS_SRC_ALPHA,
                    moderngl.ONE, moderngl.ONE
                )
        '''
        ...
    
    @blend_func.setter
    def blend_func(self, value): # -> None:
        ...
    
    @property
    def blend_equation(self):
        '''
            tuple: Set the blend equation (write only).

            Blend equations specify how source and destination colors are combined
            in blending operations. By default ``FUNC_ADD`` is used.

            Blend equation can be set for rgb and alpha separately if needed.

            Supported functions are::

                moderngl.FUNC_ADD               # source + destination
                moderngl.FUNC_SUBTRACT          # source - destination
                moderngl.FUNC_REVERSE_SUBTRACT  # destination - source
                moderngl.MIN                    # Minimum of source and destination
                moderngl.MAX                    # Maximum of source and destination

            Example::

                # For both rgb and alpha channel
                ctx.blend_func = moderngl.FUNC_ADD

                # Separate for rgb and alpha channel
                ctx.blend_func = moderngl.FUNC_ADD, moderngl.MAX
        '''
        ...
    
    @blend_equation.setter
    def blend_equation(self, value): # -> None:
        ...
    
    @property
    def multisample(self) -> bool:
        '''
            bool: Enable/disable multisample mode (``GL_MULTISAMPLE``).
            This property is write only.

            Example::

                # Enable
                ctx.multisample = True
                # Disable
                ctx.multisample = False
        '''
        ...
    
    @multisample.setter
    def multisample(self, value): # -> None:
        ...
    
    @property
    def provoking_vertex(self):
        '''int: Specifies the vertex to be used as the source of data for flat shaded varyings.

            Flatshading a vertex shader varying output (ie. ``flat out vec3 pos``) means to assign
            all vetices of the primitive the same value for that output. The vertex from which
            these values is derived is known as the provoking vertex.

            It can be configured to be the first or the last vertex.

            This property is write only.

            Example::

                # Use first vertex
                ctx.provoking_vertex = moderngl.FIRST_VERTEX_CONVENTION

                # Use last vertex
                ctx.provoking_vertex = moderngl.LAST_VERTEX_CONVENTION 
        '''
        ...
    
    @provoking_vertex.setter
    def provoking_vertex(self, value): # -> None:
        ...
    
    @property
    def viewport(self) -> Tuple[int, int, int, int]:
        '''
            tuple: Get or set the viewport of the active framebuffer.

            Example::

                >>> ctx.viewport
                (0, 0, 1280, 720)
                >>> ctx.viewport = (0, 0, 640, 360)
                >>> ctx.viewport
                (0, 0, 640, 360)

            If no framebuffer is bound ``(0, 0, 0, 0)`` will be returned.
        '''
        ...
    
    @viewport.setter
    def viewport(self, value): # -> None:
        ...
    
    @property
    def scissor(self) -> Tuple[int, int, int, int]:
        '''
            tuple: Get or set the scissor box for the active framebuffer

            When scissor testing is enabled fragments outside
            the defined scissor box will be discarded. This
            applies to rendered geometry or :py:meth:`Context.clear`.

            Setting is value enables scissor testing in the framebuffer.
            Setting the scissor to ``None`` disables scissor testing
            and reverts the scissor box to match the framebuffer size.

            Example::

                # Enable scissor testing
                >>> ctx.scissor = 100, 100, 200, 100
                # Disable scissor testing
                >>> ctx.scissor = None

            If no framebuffer is bound ``(0, 0, 0, 0)`` will be returned.
        '''
        ...
    
    @scissor.setter
    def scissor(self, value): # -> None:
        ...
    
    @property
    def max_samples(self) -> int:
        '''
            int: The maximum supported number of samples for multisampling
        '''
        ...
    
    @property
    def max_integer_samples(self) -> int:
        '''
            int: The max integer samples.
        '''
        ...
    
    @property
    def max_texture_units(self) -> int:
        '''
            int: The max texture units.
        '''
        ...
    
    @property
    def default_texture_unit(self) -> int:
        '''
            int: The default texture unit.
        '''
        ...
    
    @default_texture_unit.setter
    def default_texture_unit(self, value): # -> None:
        ...
    
    @property
    def max_anisotropy(self):
        '''
            float: The maximum value supported for anisotropic filtering.
        '''
        ...
    
    @property
    def screen(self) -> Framebuffer:
        '''
            Framebuffer: A Framebuffer instance representing the screen usually
            set when creating a context with ``create_context()`` attaching to
            an existing context. This is the special system framebuffer
            represented by framebuffer ``id=0``.

            When creating a standalone context this property is not set.
        '''
        ...
    
    @property
    def wireframe(self) -> bool:
        '''
            bool: Wireframe settings for debugging.
        '''
        ...
    
    @wireframe.setter
    def wireframe(self, value): # -> None:
        ...
    
    @property
    def front_face(self) -> str:
        '''
            str: The front_face. Acceptable values are ``'ccw'`` (default) or ``'cw'``.

            Face culling must be enabled for this to have any effect:
            ``ctx.enable(moderngl.CULL_FACE)``.

            Example::

                # Triangles winded counter-clockwise considered front facing
                ctx.front_face = 'ccw'
                # Triangles winded clockwise considered front facing
                ctx.front_face = 'cw'
        '''
        ...
    
    @front_face.setter
    def front_face(self, value): # -> None:
        ...
    
    @property
    def cull_face(self) -> str:
        '''
            str: The face side to cull. Acceptable values are ``'back'`` (default) ``'front'`` or ``'front_and_back'``.

            This is similar to :py:meth:`Context.front_face`

            Face culling must be enabled for this to have any effect:
            ``ctx.enable(moderngl.CULL_FACE)``.

            Example::

                #
                ctx.cull_face = 'front'
                #
                ctx.cull_face = 'back'
                #
                ctx.cull_face = 'front_and_back'
        '''
        ...
    
    @cull_face.setter
    def cull_face(self, value): # -> None:
        ...
    
    @property
    def patch_vertices(self) -> int:
        '''
            int: The number of vertices that will be used to make up a single patch
                 primitive.
        '''
        ...
    
    @patch_vertices.setter
    def patch_vertices(self, value): # -> None:
        ...
    
    @property
    def error(self) -> str:
        '''
            str: The result of ``glGetError()`` but human readable.
            This values is provided for debug purposes only and is likely to
            reduce performace when used in a draw loop.
        '''
        ...
    
    @property
    def extensions(self) -> Set[str]:
        '''
            Set[str]: The extensions supported by the context

            All extensions names have a ``GL_`` prefix, so if the spec refers to ``ARB_compute_shader``
            we need to look for ``GL_ARB_compute_shader``::

                # If compute shaders are supported ...
                >> "GL_ARB_compute_shader" in ctx.extensions
                True                

            Example data::

                {
                    'GL_ARB_multi_bind',
                    'GL_ARB_shader_objects',
                    'GL_ARB_half_float_vertex',
                    'GL_ARB_map_buffer_alignment',
                    'GL_ARB_arrays_of_arrays',
                    'GL_ARB_pipeline_statistics_query', 
                    'GL_ARB_provoking_vertex',
                    'GL_ARB_gpu_shader5',
                    'GL_ARB_uniform_buffer_object',
                    'GL_EXT_blend_equation_separate',
                    'GL_ARB_tessellation_shader',
                    'GL_ARB_multi_draw_indirect',
                    'GL_ARB_multisample',
                    .. etc ..
                }

        '''
        ...
    
    @property
    def info(self) -> Dict[str, object]:
        '''
            dict: OpenGL Limits and information about the context

            Example::

                # The maximum width and height of a texture
                >> ctx.info["GL_MAX_TEXTURE_SIZE"]
                16384

                # Vendor and renderer
                >> ctx.info["GL_VENDOR"]
                NVIDIA Corporation
                >> ctx.info["GL_RENDERER"]
                NVIDIA GeForce GT 650M OpenGL Engine

            Example data::

                {
                    'GL_VENDOR': 'NVIDIA Corporation',
                    'GL_RENDERER': 'NVIDIA GeForce GT 650M OpenGL Engine',
                    'GL_VERSION': '4.1 NVIDIA-10.32.0 355.11.10.10.40.102',
                    'GL_POINT_SIZE_RANGE': (1.0, 2047.0),
                    'GL_SMOOTH_LINE_WIDTH_RANGE': (0.5, 1.0),
                    'GL_ALIASED_LINE_WIDTH_RANGE': (1.0, 1.0),
                    'GL_POINT_FADE_THRESHOLD_SIZE': 1.0,
                    'GL_POINT_SIZE_GRANULARITY': 0.125,
                    'GL_SMOOTH_LINE_WIDTH_GRANULARITY': 0.125,
                    'GL_MIN_PROGRAM_TEXEL_OFFSET': -8.0,
                    'GL_MAX_PROGRAM_TEXEL_OFFSET': 7.0,
                    'GL_MINOR_VERSION': 1,
                    'GL_MAJOR_VERSION': 4,
                    'GL_SAMPLE_BUFFERS': 0,
                    'GL_SUBPIXEL_BITS': 8,
                    'GL_CONTEXT_PROFILE_MASK': 1,
                    'GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT': 256,
                    'GL_DOUBLEBUFFER': False,
                    'GL_STEREO': False,
                    'GL_MAX_VIEWPORT_DIMS': (16384, 16384),
                    'GL_MAX_3D_TEXTURE_SIZE': 2048,
                    'GL_MAX_ARRAY_TEXTURE_LAYERS': 2048,
                    'GL_MAX_CLIP_DISTANCES': 8,
                    'GL_MAX_COLOR_ATTACHMENTS': 8,
                    'GL_MAX_COLOR_TEXTURE_SAMPLES': 8,
                    'GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS': 233472,
                    'GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS': 231424,
                    'GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS': 80,
                    'GL_MAX_COMBINED_UNIFORM_BLOCKS': 70,
                    'GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS': 233472,
                    'GL_MAX_CUBE_MAP_TEXTURE_SIZE': 16384,
                    'GL_MAX_DEPTH_TEXTURE_SAMPLES': 8,
                    'GL_MAX_DRAW_BUFFERS': 8,
                    'GL_MAX_DUAL_SOURCE_DRAW_BUFFERS': 1,
                    'GL_MAX_ELEMENTS_INDICES': 150000,
                    'GL_MAX_ELEMENTS_VERTICES': 1048575,
                    'GL_MAX_FRAGMENT_INPUT_COMPONENTS': 128,
                    'GL_MAX_FRAGMENT_UNIFORM_COMPONENTS': 4096,
                    'GL_MAX_FRAGMENT_UNIFORM_VECTORS': 1024,
                    'GL_MAX_FRAGMENT_UNIFORM_BLOCKS': 14,
                    'GL_MAX_GEOMETRY_INPUT_COMPONENTS': 128,
                    'GL_MAX_GEOMETRY_OUTPUT_COMPONENTS': 128,
                    'GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS': 16,
                    'GL_MAX_GEOMETRY_UNIFORM_BLOCKS': 14,
                    'GL_MAX_GEOMETRY_UNIFORM_COMPONENTS': 2048,
                    'GL_MAX_INTEGER_SAMPLES': 1,
                    'GL_MAX_SAMPLES': 8,
                    'GL_MAX_RECTANGLE_TEXTURE_SIZE': 16384,
                    'GL_MAX_RENDERBUFFER_SIZE': 16384,
                    'GL_MAX_SAMPLE_MASK_WORDS': 1,
                    'GL_MAX_SERVER_WAIT_TIMEOUT': -1,
                    'GL_MAX_TEXTURE_BUFFER_SIZE': 134217728,
                    'GL_MAX_TEXTURE_IMAGE_UNITS': 16,
                    'GL_MAX_TEXTURE_LOD_BIAS': 15,
                    'GL_MAX_TEXTURE_SIZE': 16384,
                    'GL_MAX_UNIFORM_BUFFER_BINDINGS': 70,
                    'GL_MAX_UNIFORM_BLOCK_SIZE': 65536,
                    'GL_MAX_VARYING_COMPONENTS': 0,
                    'GL_MAX_VARYING_VECTORS': 31,
                    'GL_MAX_VARYING_FLOATS': 0,
                    'GL_MAX_VERTEX_ATTRIBS': 16,
                    'GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS': 16,
                    'GL_MAX_VERTEX_UNIFORM_COMPONENTS': 4096,
                    'GL_MAX_VERTEX_UNIFORM_VECTORS': 1024,
                    'GL_MAX_VERTEX_OUTPUT_COMPONENTS': 128,
                    'GL_MAX_VERTEX_UNIFORM_BLOCKS': 14,
                    'GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET': 0,
                    'GL_MAX_VERTEX_ATTRIB_BINDINGS': 0,
                    'GL_VIEWPORT_BOUNDS_RANGE': (-32768, 32768),
                    'GL_VIEWPORT_SUBPIXEL_BITS': 0,
                    'GL_MAX_VIEWPORTS': 16
                }
        '''
        ...
    
    def clear(self, red=..., green=..., blue=..., alpha=..., depth=..., *, viewport=..., color=...) -> None:
        '''
            Clear the bound framebuffer.

            If a `viewport` passed in, a scissor test will be used to clear the given viewport.
            This viewport take prescense over the framebuffers :py:attr:`~moderngl.Framebuffer.scissor`.
            Clearing can still be done with scissor if no viewport is passed in.

            This method also respects the
            :py:attr:`~moderngl.Framebuffer.color_mask` and
            :py:attr:`~moderngl.Framebuffer.depth_mask`. It can for example be used to only clear
            the depth or color buffer or specific components in the color buffer.

            If the `viewport` is a 2-tuple it will clear the
            ``(0, 0, width, height)`` where ``(width, height)`` is the 2-tuple.

            If the `viewport` is a 4-tuple it will clear the given viewport.

            Args:
                red (float): color component.
                green (float): color component.
                blue (float): color component.
                alpha (float): alpha component.
                depth (float): depth value.

            Keyword Args:
                viewport (tuple): The viewport.
        '''
        ...
    
    def enable_only(self, flags) -> None:
        '''
            Clears all existing flags applying new ones.

            Note that the enum values defined in moderngl
            are not the same as the ones in opengl.
            These are defined as bit flags so we can logical
            `or` them together.

            Available flags:

            - :py:data:`moderngl.NOTHING`
            - :py:data:`moderngl.BLEND`
            - :py:data:`moderngl.DEPTH_TEST`
            - :py:data:`moderngl.CULL_FACE`
            - :py:data:`moderngl.RASTERIZER_DISCARD`
            - :py:data:`moderngl.PROGRAM_POINT_SIZE`

            Examples::

                # Disable all flags
                ctx.enable_only(moderngl.NOTHING)

                # Ensure only depth testing and face culling is enabled
                ctx.enable_only(moderngl.DEPTH_TEST | moderngl.CULL_FACE)

            Args:
                flags (EnableFlag): The flags to enable
        '''
        ...
    
    def enable(self, flags) -> None:
        '''
            Enable flags.

            Note that the enum values defined in moderngl
            are not the same as the ones in opengl.
            These are defined as bit flags so we can logical
            `or` them together.

            For valid flags, please see :py:meth:`enable_only`.

            Examples::

                # Enable a single flag
                ctx.enable(moderngl.DEPTH_TEST)

                # Enable multiple flags
                ctx.enable(moderngl.DEPTH_TEST | moderngl.CULL_FACE | moderngl.BLEND)

            Args:
                flag (int): The flags to enable.
        '''
        ...
    
    def disable(self, flags) -> None:
        '''
            Disable flags.

            For valid flags, please see :py:meth:`enable_only`.

            Examples::

                # Only disable depth testing
                ctx.disable(moderngl.DEPTH_TEST)

                # Disable depth testing and face culling
                ctx.disable(moderngl.DEPTH_TEST | moderngl.CULL_FACE)

            Args:
                flag (int): The flags to disable.
        '''
        ...
    
    def finish(self) -> None:
        '''
            Wait for all drawing commands to finish.
        '''
        ...
    
    def copy_buffer(self, dst, src, size=..., *, read_offset=..., write_offset=...) -> None:
        '''
            Copy buffer content.

            Args:
                dst (Buffer): The destination buffer.
                src (Buffer): The source buffer.
                size (int): The number of bytes to copy.

            Keyword Args:
                read_offset (int): The read offset.
                write_offset (int): The write offset.
        '''
        ...
    
    def copy_framebuffer(self, dst, src) -> None:
        '''
            Copy framebuffer content.

            Use this method to:

                - blit framebuffers.
                - copy framebuffer content into a texture.
                - downsample framebuffers. (it will allow to read the framebuffer's content)
                - downsample a framebuffer directly to a texture.

            Args:
                dst (Framebuffer or Texture): Destination framebuffer or texture.
                src (Framebuffer): Source framebuffer.
        '''
        ...
    
    def detect_framebuffer(self, glo=...) -> Framebuffer:
        '''
            Detect framebuffer. This is already done when creating a context,
            but if the underlying window library for some changes the default framebuffer
            during the lifetime of the application this might be necessary.

            Args:
                glo (int): Framebuffer object.

            Returns:
                :py:class:`Framebuffer` object
        '''
        ...
    
    def buffer(self, data=..., *, reserve=..., dynamic=...) -> Buffer:
        '''
            Create a :py:class:`Buffer` object.

            Args:
                data (bytes): Content of the new buffer.

            Keyword Args:
                reserve (int): The number of bytes to reserve.
                dynamic (bool): Treat buffer as dynamic.

            Returns:
                :py:class:`Buffer` object
        '''
        ...
    
    def texture(self, size, components, data=..., *, samples=..., alignment=..., dtype=..., internal_format=...) -> Texture:
        '''
            Create a :py:class:`Texture` object.

            .. Warning:: Do not play with ``internal_format`` unless you know exactly
                         you are doing. This is an override to support sRGB and
                         compressed textures if needed.

            Args:
                size (tuple): The width and height of the texture.
                components (int): The number of components 1, 2, 3 or 4.
                data (bytes): Content of the texture.

            Keyword Args:
                samples (int): The number of samples. Value 0 means no multisample format.
                alignment (int): The byte alignment 1, 2, 4 or 8.
                dtype (str): Data type.
                internal_format (int): Override the internalformat of the texture (IF needed)

            Returns:
                :py:class:`Texture` object
        '''
        ...
    
    def texture_array(self, size, components, data=..., *, alignment=..., dtype=...) -> TextureArray:
        '''
            Create a :py:class:`TextureArray` object.

            Args:
                size (tuple): The ``(width, height, layers)`` of the texture.
                components (int): The number of components 1, 2, 3 or 4.
                data (bytes): Content of the texture. The size must be ``(width, height * layers)``
                              so each layer is stacked vertically.

            Keyword Args:
                alignment (int): The byte alignment 1, 2, 4 or 8.
                dtype (str): Data type.

            Returns:
                :py:class:`Texture3D` object
        '''
        ...
    
    def texture3d(self, size, components, data=..., *, alignment=..., dtype=...) -> Texture3D:
        '''
            Create a :py:class:`Texture3D` object.

            Args:
                size (tuple): The width, height and depth of the texture.
                components (int): The number of components 1, 2, 3 or 4.
                data (bytes): Content of the texture.

            Keyword Args:
                alignment (int): The byte alignment 1, 2, 4 or 8.
                dtype (str): Data type.

            Returns:
                :py:class:`Texture3D` object
        '''
        ...
    
    def texture_cube(self, size, components, data=..., *, alignment=..., dtype=...) -> TextureCube:
        '''
            Create a :py:class:`TextureCube` object.

            Args:
                size (tuple): The width, height of the texture. Each side of
                              the cube will have this size.
                components (int): The number of components 1, 2, 3 or 4.
                data (bytes): Content of the texture. The data should be have the following ordering:
                              positive_x, negative_x, positive_y, negative_y, positive_z + negative_z

            Keyword Args:
                alignment (int): The byte alignment 1, 2, 4 or 8.
                dtype (str): Data type.

            Returns:
                :py:class:`TextureCube` object
        '''
        ...
    
    def depth_texture(self, size, data=..., *, samples=..., alignment=...) -> Texture:
        '''
            Create a :py:class:`Texture` object.

            Args:
                size (tuple): The width and height of the texture.
                data (bytes): Content of the texture.

            Keyword Args:
                samples (int): The number of samples. Value 0 means no multisample format.
                alignment (int): The byte alignment 1, 2, 4 or 8.

            Returns:
                :py:class:`Texture` object
        '''
        ...
    
    def vertex_array(self, *args, **kwargs) -> VertexArray:
        '''
            Create a :py:class:`VertexArray` object.

            This method also supports arguments for :py:meth:`Context.simple_vertex_array`.

            Args:
                program (Program): The program used when rendering.
                content (list): A list of (buffer, format, attributes).
                                See :ref:`buffer-format-label`.
                index_buffer (Buffer): An index buffer.

            Keyword Args:
                index_element_size (int): byte size of each index element, 1, 2 or 4.
                skip_errors (bool): Ignore skip_errors varyings.

            Returns:
                :py:class:`VertexArray` object
        '''
        ...
    
    def simple_vertex_array(self, program, buffer, *attributes, index_buffer=..., index_element_size=...) -> VertexArray:
        '''
            Create a :py:class:`VertexArray` object.

            .. Warning:: This method is deprecated and may be removed in the future.
                         Use :py:meth:`Context.vertex_array` instead. It also supports
                         the argument format this method describes.

            Args:
                program (Program): The program used when rendering.
                buffer (Buffer): The buffer.
                attributes (list): A list of attribute names.

            Keyword Args:
                index_element_size (int): byte size of each index element, 1, 2 or 4.
                index_buffer (Buffer): An index buffer.

            Returns:
                :py:class:`VertexArray` object
        '''
        ...
    
    def program(self, *, vertex_shader, fragment_shader=..., geometry_shader=..., tess_control_shader=..., tess_evaluation_shader=..., varyings=...) -> Program:
        '''
            Create a :py:class:`Program` object.

            Only linked programs will be returned.

            A single shader in the `shaders` parameter is also accepted.
            The varyings are only used when a transform program is created.

            Args:
                shaders (list): A list of :py:class:`Shader` objects.
                varyings (list): A list of varying names.

            Returns:
                :py:class:`Program` object
        '''
        ...
    
    def query(self, *, samples=..., any_samples=..., time=..., primitives=...) -> Query:
        '''
            Create a :py:class:`Query` object.

            Keyword Args:
                samples (bool): Query ``GL_SAMPLES_PASSED`` or not.
                any_samples (bool): Query ``GL_ANY_SAMPLES_PASSED`` or not.
                time (bool): Query ``GL_TIME_ELAPSED`` or not.
                primitives (bool): Query ``GL_PRIMITIVES_GENERATED`` or not.
        '''
        ...
    
    def scope(self, framebuffer=..., enable_only=..., *, textures=..., uniform_buffers=..., storage_buffers=..., samplers=..., enable=...) -> Scope:
        '''
            Create a :py:class:`Scope` object.

            Args:
                framebuffer (Framebuffer): The framebuffer to use when entering.
                enable_only (int): The enable_only flags to set when entering.

            Keyword Args:
                textures (list): List of (texture, binding) tuples.
                uniform_buffers (list): List of (buffer, binding) tuples.
                storage_buffers (list): List of (buffer, binding) tuples.
                samplers (list): List of sampler bindings
                enable (int): Flags to enable for this vao such as depth testing and blending
        '''
        ...
    
    def simple_framebuffer(self, size, components=..., *, samples=..., dtype=...) -> Framebuffer:
        '''
            Creates a :py:class:`Framebuffer` with a single color attachment
            and depth buffer using :py:class:`moderngl.Renderbuffer` attachments.

            Args:
                size (tuple): The width and height of the renderbuffer.
                components (int): The number of components 1, 2, 3 or 4.

            Keyword Args:
                samples (int): The number of samples. Value 0 means no multisample format.
                dtype (str): Data type.

            Returns:
                :py:class:`Framebuffer` object
        '''
        ...
    
    def framebuffer(self, color_attachments=..., depth_attachment=...) -> Framebuffer:
        '''
            A :py:class:`Framebuffer` is a collection of buffers that can be
            used as the destination for rendering. The buffers for Framebuffer
            objects reference images from either Textures or Renderbuffers.

            Args:
                color_attachments (list): A list of :py:class:`Texture` or
                                          :py:class:`Renderbuffer` objects.
                depth_attachment (Renderbuffer or Texture): The depth attachment.

            Returns:
                :py:class:`Framebuffer` object
        '''
        ...
    
    def renderbuffer(self, size, components=..., *, samples=..., dtype=...) -> Renderbuffer:
        '''
            :py:class:`Renderbuffer` objects are OpenGL objects that contain images.
            They are created and used specifically with :py:class:`Framebuffer` objects.

            Args:
                size (tuple): The width and height of the renderbuffer.
                components (int): The number of components 1, 2, 3 or 4.

            Keyword Args:
                samples (int): The number of samples. Value 0 means no multisample format.
                dtype (str): Data type.

            Returns:
                :py:class:`Renderbuffer` object
        '''
        ...
    
    def depth_renderbuffer(self, size, *, samples=...) -> Renderbuffer:
        '''
            :py:class:`Renderbuffer` objects are OpenGL objects that contain images.
            They are created and used specifically with :py:class:`Framebuffer` objects.

            Args:
                size (tuple): The width and height of the renderbuffer.

            Keyword Args:
                samples (int): The number of samples. Value 0 means no multisample format.

            Returns:
                :py:class:`Renderbuffer` object
        '''
        ...
    
    def compute_shader(self, source) -> ComputeShader:
        '''
            A :py:class:`ComputeShader` is a Shader Stage that is used entirely
            for computing arbitrary information. While it can do rendering, it
            is generally used for tasks not directly related to drawing.

            Args:
                source (str): The source of the compute shader.

            Returns:
                :py:class:`ComputeShader` object
        '''
        ...
    
    def sampler(self, repeat_x=..., repeat_y=..., repeat_z=..., filter=..., anisotropy=..., compare_func=..., border_color=..., min_lod=..., max_lod=..., texture=...) -> Sampler:
        '''
            Create a :py:class:`Sampler` object.

            Keyword Arguments:
                repeat_x (bool): Repeat texture on x
                repeat_y (bool): Repeat texture on y
                repeat_z (bool): Repeat texture on z
                filter (tuple): The min and max filter
                anisotropy (float): Number of samples for anisotropic filtering.
                                    Any value greater than 1.0 counts as a use of
                                    anisotropic filtering
                compare_func: Compare function for depth textures
                border_color (tuple): The (r, g, b, a) color for the texture border.
                                      When this value is set the ``repeat_`` values are
                                      overridden setting the texture wrap to return the
                                      border color when outside ``[0, 1]`` range.
                min_lod (float): Minimum level-of-detail parameter (Default ``-1000.0``).
                                 This floating-point value limits the selection of highest
                                 resolution mipmap (lowest mipmap level)
                max_lod (float): Minimum level-of-detail parameter (Default ``1000.0``).
                                 This floating-point value limits the selection of the
                                 lowest resolution mipmap (highest mipmap level)
                texture (Texture): The texture for this sampler
        '''
        ...
    
    def clear_samplers(self, start=..., end=...): # -> None:
        '''
            Unbinds samplers from texture units.
            Sampler bindings do clear automatically between every frame,
            but lingering samplers can still be a source of weird bugs during
            the frame rendering. This methods provides a fairly brute force
            and efficient way to ensure texture units are clear.

            Keyword Arguments:

                start (int): The texture unit index to start the clearing samplers
                stop (int): The texture unit index to stop clearing samplers

            Example::

                # Clear texture unit 0, 1, 2, 3, 4
                ctx.clear_samplers(start=0, end=5)

                # Clear texture unit 4, 5, 6, 7
                ctx.clear_samplers(start=4, end=8)
        '''
        ...
    
    def core_profile_check(self) -> None:
        '''
            Core profile check.

            FOR DEBUG PURPOSES ONLY
        '''
        ...
    
    def __enter__(self): # -> Self@Context:
        """Enters the context.
        
        This should ideally be used with the ``with`` statement::

            with other_context as ctx:
                # Do something in this context

        When exiting the context the previously bound context is activated again.

        .. Warning:: Context switching can be risky unless you know what you are doing.
                     Use with care.
        """
        ...
    
    def __exit__(self, exc_type, exc_val, exc_tb): # -> None:
        """Exit the context.

        See :py:meth:`Context.__enter__`
        """
        ...
    
    def release(self) -> None:
        '''
            Release the ModernGL context.

            If the context is not standalone the standard
            backends in ``glcontext`` will not do anything
            because the context was not created by moderngl.

            Standalone contexts can normally be released.
        '''
        ...
    


def create_context(require=..., standalone=..., share=..., **settings) -> Context:
    '''
        Create a ModernGL context by loading OpenGL functions from an existing OpenGL context.
        An OpenGL context must exists.

        Example::

            # Accept the current context version
            ctx = moderngl.create_context()

            # Require at least OpenGL 4.3
            ctx = moderngl.create_context(require=430)

            # Create a headless context requiring OpenGL 4.3
            ctx = moderngl.create_context(require=430, standalone=True)

        Keyword Arguments:
            require (int): OpenGL version code (default: 330)
            standalone (bool): Headless flag
            **settings: Other backend specific settings

        Returns:
            :py:class:`Context` object
    '''
    ...

def create_standalone_context(require=..., share=..., **settings) -> Context:
    '''
        Create a standalone/headless ModernGL context.
        The preferred way of making a context is through :py:func:`moderngl.create_context`.

        Example::

            # Create a context with highest possible supported version
            ctx = moderngl.create_context()

            # Require at least OpenGL 4.3
            ctx = moderngl.create_context(require=430)

        Keyword Arguments:
            require (int): OpenGL version code.

        Returns:
            :py:class:`Context` object
    '''
    ...

